{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017/02/tile-based-layouts-and-esi-on-plone.html/","result":{"data":{"site":{"siteMetadata":{"title":"Asko Soukka","author":"Asko Soukka"}},"markdownRemark":{"id":"c83db711-62bb-5ae6-a8a7-887aec709b7b","fields":{"slug":"/2017/02/tile-based-layouts-and-esi-on-plone.html/"},"excerpt":"Plone’s Blocks: Grid based\nlayouts is an old manifest (originally dated back to 2008 or 2009)\nabout simplifying Plone’s (ME)TAL-macros, content providers…","html":"<p>Plone’s <a href=\"https://github.com/plone/plone.app.mosaic/raw/master/docs/Blocks.pdf\">Blocks: Grid based\nlayouts</a> is an old manifest (originally dated back to 2008 or 2009)\nabout simplifying <a href=\"https://www.plone.org/\">Plone</a>’s (ME)TAL-macros, content providers (portlets and viewlets)\nbased layout machinery with a composition of independently rendered\nstatic HTML layouts and dynamic content tiles. The initial\nimplementation of the manifest was completed already by 2011 with the\nfirst versions of\n<a href=\"https://pypi.python.org/pypi/plone.tiles\">plone.tiles</a> and\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">plone.app.blocks</a>. It was supposed to be a core part of Plone 5, but continues\nto be delayed because the failure of the Plone Deco project. Sad.</p>\n<p>Because of the separation of content and composition, the new approach\nintroduced new options for the actual page rendering process: It was no\nlonger necessary to render a complete Plone page at once, but each page\ncould be composed of multiple independently rendered and cached content\nfragment. Of course, the complete rendering could still be done on Plone\nat once like before, but it also became possible to compose the page\nfrom its fragments with\n<a href=\"https://en.wikipedia.org/wiki/Edge_Side_Includes\">ESI</a> (Edge Side Includes) in a compatible caching proxy, or with\nJavaScript (e.g. with\n<a href=\"http://patternslib.com/inject/\">pat-inject</a>{.reference .external}) in\nan end users browser. Both of these approaches providing parallel\nrendering of page fragments, while each of those fragment could be\ncached independently simply by using the standard HTTP caching headers.\nWhich is great.</p>\n<p>So, what could all this mean in practice? Thanks to tile based layouts,\nVarnish and ESI, we are now able to cache every cacheable part of our\npages also for logged-in users, resulting in noticeably better\nperformance and user experience.</p>\n<p>(And yes, this approach may look already outdated, when compared various\nfront-end based composition options of headless CMS era, but still\nsolves real issues with the current Plone with server-rendered HTML.)</p>\n<h2>Blocks rendering process revisited</h2>\n<p>To really understand the goals of tile based layouts, let’s revisit the\nonce revolutionary page composition process implemented in\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">plone.app.blocks</a>.</p>\n<p>In the simplest form of rendering, a Plone page could still render a\ncomplete HTML document as before:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\" cm-s-solarized\"><code><span>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- ... --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</span></code></pre>\n    </div>\n<p>But instead of always rendering everything, with tile based layouts it\nbecome possible to speed up the main rendering of the page by delegating\nthe rendering of dynamic parts of the page to separate independent\nrenderers, called tiles:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\" cm-s-solarized\"><code><span>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- ... --&gt;\n  &lt;div data-tile=\"TILE_URL\" /&gt;\n  &lt;!-- ... --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</span></code></pre>\n    </div>\n<p>The page rendering output could include as many plaholder elements with\n<code>data-tile</code>-attribute as required, and expect\nsomething later to replace those elements with the contents defined by\ntheir URL values. This <em>something</em> is still Plone by default, but it\ncould also be a middleware (like ESI in caching proxy) or JavaScript in\na browser.</p>\n<p>The main benefits from decoupling rendering and composition like this\ninclude (with either ESI or JavaScript -based composition) include:</p>\n<ol>\n<li>Experiential speed-up, because the main page may be already\npartially or completely visible in the browser while the delegated\nparts are still being rendered</li>\n<li>real speed-up, because the delegated parts may be rendered in\nparallel</li>\n<li>real speed-up, because the delegated parts may be cached separately\nwith optimized HTTP caching headeaders.</li>\n</ol>\n<p>It’s crucial that the value of <code>data-tile</code>\nattribute is full absolute or relative URL, and that the target address\ncan be rendered independently from the main page. These assumptions\nwould make the composition logically independent from then underlying\nserver technology. It’s even possible to compose page from snippets\nrendered by multiple different services.</p>\n<p>In addition to the <code>data-tile</code>-composition,\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">plone.app.blocks</a> provides an additional composition to separate content area\npage design (content layout) from its surroundings (site layout).</p>\n<p>To use this additional site layout composition, a page rendering must\ndefine the URL of the used site layout and the panels (slots) it fills\ninto that layout by using the additional data-attributes\n<code>data-layout</code> and <code>data-panel</code>\nas in the following example:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\" cm-s-solarized\"><code><span>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body data-layout=\"LAYOUT_URL\"&gt;\n  &lt;div data-panel=\"PANEL_ID\"&gt;\n    &lt;!-- ... --&gt;\n    &lt;div data-tile=\"TILE_URL\" /&gt;\n    &lt;!-- ... --&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</span></code></pre>\n    </div>\n<p>Together, these attributes instruct the composition as follows: Please,\nload a site layout at <code>LAYOUT_URL</code> and render it\nwith its panel named <code>PANEL_ID</code> filled with\nchildrens of this tag.</p>\n<p>So, if the site layout in question would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\" cm-s-solarized\"><code><span>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- ... --&gt;\n  &lt;div data-panel=\"PANEL_ID\"&gt;\n    &lt;!-- ... --&gt;\n  &lt;/div&gt;\n  &lt;!-- ... --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</span></code></pre>\n    </div>\n<p>The main rendering of the page would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\" cm-s-solarized\"><code><span>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- ... --&gt;\n  &lt;div&gt;\n    &lt;!-- ... --&gt;\n    &lt;div data-tile=\"TILE_URL\" /&gt;\n    &lt;!-- ... --&gt;\n  &lt;/div&gt;\n  &lt;!-- ... --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</span></code></pre>\n    </div>\n<p>Obviously, the site layout could define multiple panels, and the content\nlayout could fill anything from none to all of them.</p>\n<p>Currently, this so called <em>panel merge</em> is always done by Plone with\ntransform code in\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">plone.app.blocks</a>, but technically this could also be done e.g. in a WSGI\nmiddleware, releasing Plone worker threads even more earlier than is\ncurrently possible with just ESI or browser side composition of tiles.</p>\n<h2>Caching ESI tiles for logged-in users</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Edge_Side_Includes\">ESI</a> (Edge Side Includes) is an old proposal (mainly by Akamai)\nfor an XML namespace to describe HTML page composition from multiple\nseparate resources. A quite minimal subset of the language is\nimplemented also in\n<a href=\"https://varnish-cache.org/docs/4.1/users-guide/esi.html\">Varnish</a>, a popular and recommended caching proxy also in Plone\nsetups.</p>\n<p>Using and enabling ESI with\n<a href=\"https://pypi.python.org/pypi/plone.tiles\">plone.tiles</a>,\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">plone.app.blocks</a> and\n<a href=\"https://varnish-cache.org/docs/4.1/users-guide/esi.html\">Varnish</a> is well documented in those packages’ READMEs. Yet,\nsomething we discovered only very recently was, how to use ESI to safely\ncache tiles for logged-in users.</p>\n<p>Of course, by default, Plone never caches anything for logged-in-users.\nAt first,\n<a href=\"https://pypi.python.org/pypi/plone.app.caching\">plone.app.caching</a> declares all responses private, unless they should be visible\nfor anonymous users. And then, the recommended Varnish configuration\nskips caches whenever Plone session cookie is present in request. So, by\ndefault, we are protected from both sides. (And that’s great design to\nprotect us from our own mistakes!)</p>\n<p>The first step to support caching for logged-in users is to allow\nVarnish (in <code>default.vcl</code>) to do cache lookup for\nESI tiles:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>sub vcl_recv {\n  # ...\n  if (req.esi_level &gt; 0) {\n      set req.http.X-Esi-Level = req.esi_level;\n      return (hash);\n  } else {\n      unset req.http.X-Esi-Level;\n  }\n  # ....</span></code></pre>\n    </div>\n<p>Of course, this would allow lookup for only completely public tiles,\nbecause only those could be cached by Varnish by default. That’s why,\nin the example above, we also manage a completely new header\n<code>X-Esi-Level</code>, and we make sure it’s only available\nwhen Varnish is doing its internal subrequests for ESI-tiles.</p>\n<p>With that extra header in place, we can instruct Varnish to hash\nresponses to ESI-subrequests separately from responses to main requests.\nIn other words, we split Varnish cache into public and private areas.\nWhile public cache remains accessible for anyone knowning just the\ncached URL, the private one is only accessible for Varnish itself, when\nit’s doing ESI subrequests:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>sub vcl_hash {\n    hash_data(req.url);\n    if (req.http.host) {\n        hash_data(req.http.host);\n    } else {\n        hash_data(server.ip);\n    }\n    if (req.http.X-Esi-Level) {\n       hash_data(req.http.X-Esi-Level);\n    }\n    return (lookup);\n}</span></code></pre>\n    </div>\n<p>Now we are almost ready to patch let Plone to allow caching of\nrestricted tiles. But only tiles. Because of <code>X-Esi-Level</code> would only be set for Varnish’s internal subrequests for\ntiles, all other requests would be handled as before. This patch is done\nby monkeypatching an utility method in\n<a href=\"https://pypi.python.org/pypi/plone.app.caching\">plone.app.caching</a> to allow public <code>Cache-Control</code>-header\nfor otherwise restricted tiles when the trusted <code>X-Esi-Level</code>-header is in place:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">visibleToRole</span><span>(</span><span class=\"cm-variable\">published</span><span>, </span><span class=\"cm-variable\">role</span><span>, </span><span class=\"cm-variable\">permission</span><span class=\"cm-operator\">=</span><span class=\"cm-string\">'View'</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-variable\">request</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">getRequest</span><span>()</span><span>\n</span><span>    </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-variable\">request</span><span>.</span><span class=\"cm-property\">getHeader</span><span>(</span><span class=\"cm-string\">'X-Esi-Level'</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-keyword\">True</span><span>\n</span><span>    </span><span class=\"cm-keyword\">else</span><span>:</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-variable\">role</span><span> </span><span class=\"cm-keyword\">in</span><span> </span><span class=\"cm-variable\">rolesForPermissionOn</span><span>(</span><span class=\"cm-variable\">permission</span><span>, </span><span class=\"cm-variable\">published</span><span>)</span></code></pre>\n    </div>\n<p>Please, don’t do this, unless you really know and test what you are\ndoing!</p>\n<p>Because something crucial is still missing: Even with the private cache\nfor ESI tiles, Varnish will still cache tiles just by URL. And that\nwould mean that, by default, all users would get whatever version of the\ntile was cached first.</p>\n<p>To really make it safe to cache restricted tiles for logged-in users, we\nmust ensure that cacheable tiles should have unique URL for users with\ndifferent roles. We fixed this by implementing a custom transform, which\nhashes roles of the current user (with time based salt) into an extra\nquery string parameter for each tile URL in the rendered page. The\nresult: <strong>users with same set of roles share the same cache of tiles</strong>.\nFast.</p>","frontmatter":{"title":"Tile based layouts and ESI on Plone","tags":["Blocks","ESI","Plone","Tiles","Varnish"],"date":"February 26, 2017","published":"2017-02-26 06:00:00"}}},"pageContext":{"slug":"/2017/02/tile-based-layouts-and-esi-on-plone.html/","previous":{"fields":{"slug":"/2016/10/on-building-fat-themes-for-plone.html/"},"frontmatter":{"title":"On building fat themes for Plone"}},"next":{"fields":{"slug":"/2017/10/building-instant-features-with-advanced.html/"},"frontmatter":{"title":"Building instant features with advanced Plone themes"}}}},"staticQueryHashes":["63159454"],"slicesMap":{}}