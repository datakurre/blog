{"componentChunkName":"component---src-templates-blog-post-js","path":"/2016/04/evolution-of-our-makefile-for-docker.html/","result":{"data":{"site":{"siteMetadata":{"title":"Asko Soukka","author":"Asko Soukka"}},"markdownRemark":{"id":"97144175-cafe-5832-a3b6-0dbe6a57ca6d","fields":{"slug":"/2016/04/evolution-of-our-makefile-for-docker.html/"},"excerpt":"It’s hard to move to GitLab and resist the\ntemptation of its integrated GitLab\nCI. And with GitLab CI, it’s just\nnatural to run all CI jobs in Docker\ncontainers…","html":"<p>It’s hard to move to <a href=\"https://gitlab.com/\">GitLab</a> and resist the\ntemptation of its integrated <a href=\"https://about.gitlab.om/gitlab-ci/\">GitLab\nCI</a>. And with GitLab CI, it’s just\nnatural to run all CI jobs in <a href=\"https://www.docker.com/\">Docker</a>\ncontainers. Yet, to avoid vendor lock of its integrated Docker support,\nwe choosed to keep our <code>.gitlab-ci.yml</code> configurations minimal and do\nall Docker calls with <a href=\"https://www.gnu.org/software/make/\">GNU make</a>\ninstead. This also ensured, that all of our CI tasks remain locally\nreproducible. In addition, we wanted to use <em>official</em> upstream Docker\nimages from the official hub as far as possible.</p>\n<p><img src=\"/621cc93fbf280c0bd6e91f8df17e5ed8/IMG_0370.jpg\" alt=\"image\"></p>\n<p>As always with make, it it’s a danger that Makefiles themselves become\nprojects of their own. So, let’s begin with a completely hypothetical\n<code>Makefile</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>all: test\n\ntest:\n karma test\n\n.PHONY: all test</span></code></pre>\n    </div>\n<h2>Separation of concerns</h2>\n<p>At first, we want to keep all Docker related commands separate from the\nactual project specific commands. This lead us to have two separate\nMakefiles. A traditional default one, which expects all the build tools\nand other dependencies to exist in the running system, and a Docker\nspecific one. We named them <code>Makefile</code> (as already seen above) and\n<code>Makefile.docker</code> (below):</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>all: test\n\ntest:\n docker run --rm -v $PWD:/build -w /build node:5 make test\n\n.PHONY: all test</span></code></pre>\n    </div>\n<p>So, we simply run a Docker container of required upstream language image\n(here Node 5), mount our project into the container and run make for the\ndefault Makefile inside the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ make</span><span> </span><span class=\"cm-attribute\">-f</span><span> Makefile.docker</span></code></pre>\n    </div>\n<p>Of course, the logical next step is to abstract that Docker call into a\nfunction to make it trivial to wrap also other make targets to be run in\nDocker:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>make = docker run --rm -v $PWD:/build -w /build node:5 make $1\n\nall: test\n\ntest:\n $(call make,test)\n\n.PHONY: all test</span></code></pre>\n    </div>\n<h2>Docker specific steps in the main Makefile</h2>\n<p>In the beginning, I mentioned, that we try to use the official upstream\nDocker images whenever possible, to keep our Docker dependencies fresh\nand supported. Yet, what if we need just minor modifications to them,\nlike installation of a couple of extra packages…</p>\n<p>Because our <code>Makefile.docker</code> mostly just wraps the make call for the\ndefault Makefile into a auto-removed Docker container run\n(<code>docker run --rm</code>), we cannot easily install extra packages into the\ncontainer in <code>Makefile.docker</code>. This is the exception, when we add\nDocker-related commands into the default <code>Makefile</code>.</p>\n<p>There are probably many ways to detect the run in Docker container, but\nmy favourite is testing the existence of <code>/.dockerenv</code> file. So, any\nDocker container specific command in <code>Makefile</code> is wrapped with test for\nthat file, as in:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>all: test\n\ntest:\n [ -f /.dockerenv ] &amp;&amp; npm -g i karma || true\n karma test\n\n.PHONY: all test</span></code></pre>\n    </div>\n<h2>Getting rid of the filesystem side-effects</h2>\n<p>Unfortunately, one does not simply mount a source directory from the\nhost into a container and run arbitrary commands with arbitrary users\nwith that mount in place. (Unless one wants to play to game of having\nmatching user ids inside and outside the container.)</p>\n<p>To avoid all issues related to Docker possibly trying to (and sometimes\nsucceeding in) creating files into mounted host file system, we may run\nDocker without host mount at all, by piping project sources into the\ncontainer:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>make = git archive HEAD | \\\n       docker run -i --rm -v /build -w /build node:5 \\\n       bash -c \"tar x --warning=all &amp;&amp; make $1\"\n\nall: test\n\ntest: bin/test\n $(call make,test)\n\n.PHONY: all test</span></code></pre>\n    </div>\n<ul>\n<li><code>git archive HEAD</code> writes tarball of the project git repository HEAD\n(latest commit) into stdout.</li>\n<li><code>-i</code> in <code>docker run</code> enables stdin in Docker.</li>\n<li><code>-v /build</code> in <code>docker run</code> ensures <code>/build</code> to exist in container\n(as a temporary volume).</li>\n<li><code>bash -c \"tar x --warning=all &#x26;&#x26; make $1\"</code> is the single command to\nbe run in the container (<code>bash</code> with arguments). It extracts the\npiped tarball from stdin into the current working directory in\ncontainer (<code>/build</code>) and then executes given make target from the\nextracted tarball contents’ <code>Makefile</code>.</li>\n</ul>\n<h2>Caching dependencies</h2>\n<p>One well known issue with Docker based builds is the amount of language\nspecific dependencies required by your project on top of the official\nlanguage image. We’ve solved this by creating a persistent data volume\nfor those dependencies, and share that volume from build to build.</p>\n<p>For example, defining a persistent NPM cache in our <code>Makefile.docker</code>\nwould look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>CACHE_VOLUME = npm-cache\n\nmake = git archive HEAD | \\\n       docker run -i --rm -v $(CACHE_VOLUME):/cache \\\n       -v /build -w /build node:5 \\\n       bash -c \"tar x --warning=all &amp;&amp; make \\\n       NPM_INSTALL_ARGS='--cache /cache --cache-min 604800' $1\"\n\nall: test\n\ntest: bin/test\n $(INIT_CACHE)\n $(call make,test)\n\n.PHONY: all test\n\nINIT_CACHE = \\\n    docker volume ls | grep $(CACHE_VOLUME) || \\\n    docker create --name $(CACHE_VOLUME) -v $(CACHE_VOLUME):/cache node:5</span></code></pre>\n    </div>\n<ul>\n<li><code>CACHE_VOLUME</code> variable holds the fixed name for the shared volume\nand the dummy container keeping the volume from being garbage\ncollected by <code>docker run --rm</code>.</li>\n<li><code>INIT_CACHE</code> ensures that the cache volume is always present (so\nthat it can simply be removed if its state goes bad).</li>\n<li><code>-v $(CACHE_VOLUME:/cache</code> in <code>docker run</code> mounts the cache volume\ninto test container.</li>\n<li><code>NPM_INSTALL_ARGS='--cache /cache --cache-min 604800'</code> in\n<code>docker run</code> sets a make variable <code>NPM_INSTALL_ARGS</code> with arguments\nto configure cache location for NPM. That variable, of course,\nshould be explicitly defined and used in the default <code>Makefile</code>:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>NPM_INSTALL_ARGS =\n\nall: test\n\ntest:\n @[ -f /.dockerenv ] &amp;&amp; npm -g $(NPM_INSTALL_ARGS) i karma || true\n karma test\n\n.PHONY: all test</span></code></pre>\n    </div>\n<p>Cache volume, of course, adds state between the builds and may cause\nissues that require resetting the cache containers when that hapens.\nStill, most of the time, these have been working very well for us,\nsignificantly reducing the required build time.</p>\n<h2>Retrieving the build artifacts</h2>\n<p>The downside of running Docker without mounting anything from the host\nis that it’s a bit harder to get build artifacts (e.g. test reports)\nout of the container. We’ve tried both stdout and <code>docker cp</code> for this.\nAt the end we ended up using dedicated build data volume and <code>docker cp</code>\nin <code>Makefile.docker</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"make\">\n      <pre class=\" cm-s-solarized\"><code><span>CACHE_VOLUME = npm-cache\nDOCKER_RUN_ARGS =\n\nmake = git archive HEAD | \\\n       docker run -i --rm -v $(CACHE_VOLUME):/cache \\\n       -v /build -w /build $(DOCKER_RUN_ARGS) node:5 \\\n       bash -c \"tar x --warning=all &amp;&amp; make \\\n       NPM_INSTALL_ARGS='--cache /cache --cache-min 604800' $1\"\n\nall: test\n\ntest: DOCKER_RUN_ARGS = --volumes-from=$(BUILD)\ntest: bin/test\n $(INIT_CACHE)\n $(call make,test); \\\n   status=$$?; \\\n   docker cp $(BUILD):/build .; \\\n   docker rm -f -v $(BUILD); \\\n   exit $$status\n\n.PHONY: all test\n\nINIT_CACHE = \\\n    docker volume ls | grep $(CACHE_VOLUME) || \\\n    docker create --name $(CACHE_VOLUME) -v $(CACHE_VOLUME):/cache node:5\n\n# http://cakoose.com/wiki/gnu_make_thunks\nBUILD_GEN = $(shell docker create -v /build node:5\nBUILD = $(eval BUILD := $(BUILD_GEN))$(BUILD)</span></code></pre>\n    </div>\n<p>A few powerful make patterns here:</p>\n<ul>\n<li><code>DOCKER_RUN_ARGS =</code> sets a placeholder variable for injecting make\ntarget specific options into <code>docker run</code>.</li>\n<li><code>test: DOCKER_RUN_ARGS = --volumes-from=$(BUILD)</code> sets a make target\nlocal value for <code>DOCKER_RUN_ARGS</code>. Here it adds volumes from a\ncontainer uuid defined in variable <code>BUILD</code>.</li>\n<li><code>BUILD</code> is a lazily evaluated Make variable (created with <a href=\"http://cakoose.com/wiki/gnu_make_thunks\">GNU make\nthunk -pattern</a>). It gets\nits value when it’s used for the first time. Here it is set to an\nid of a new container with a shareable volume at <code>/build</code> so that\n<code>docker run</code> ends up writing all its build artifacts into that\nvolume.</li>\n<li>Because make would stop its execution after the first failing\ncommand, we must wrap the <code>make test</code> call of <code>docker run</code> so that\nwe\n<ol>\n<li>capture the original return value with <code>status=$$?</code></li>\n<li>copy the artifacts to host using <code>docker cp</code></li>\n<li>delete the build container</li>\n<li>finally return the captured status with <code>exit $$status</code>.</li>\n</ol>\n</li>\n</ul>\n<p>This pattern may look a bit complex at first, but it has been powerful\nenough to start any number of temporary containers and link or mount\nthem with the actual test container (similarly to <code>docker-compose</code>, but\ndirectly in Makefile). For example, we use this to start and link\nSelenium web driver containers to be able run Selenium based acceptance\ntests in the test container on top of upstream language base image, and\nthen retrieve the test reports from the build container volume.</p>","frontmatter":{"title":"Evolution of a Makefile for building projects with Docker","tags":["Docker","Make","Python","Selenium","Testing"],"date":"April 30, 2016","published":"2016-04-30 06:00:00"}}},"pageContext":{"slug":"/2016/04/evolution-of-our-makefile-for-docker.html/","previous":{"fields":{"slug":"/2016/04/building-plone-form-widget-with-react.html/"},"frontmatter":{"title":"Building Plone widget with React + Redux"}},"next":{"fields":{"slug":"/2016/05/plone-barcelona-sprint-2016-report.html/"},"frontmatter":{"title":"Plone Barcelona Sprint 2016 Report"}}}},"staticQueryHashes":["63159454"],"slicesMap":{}}