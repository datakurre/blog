{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014/05/asynchronous-stream-iterators-and.html/","result":{"data":{"site":{"siteMetadata":{"title":"Asko Soukka","author":"Asko Soukka"}},"markdownRemark":{"id":"5373909b-fedf-546b-81ee-a114b55c4530","fields":{"slug":"/2014/05/asynchronous-stream-iterators-and.html/"},"excerpt":"This post may contain traces of legacy Zope2 and Python 2.x. Some may think that Plone is bad in concurrency,\nbecause it’s not common to deployt it with\nWSGI…","html":"<p><em>This post may contain traces of legacy Zope2 and Python 2.x.</em></p>\n<p>Some may think that <a href=\"https://plone.org/\">Plone</a> is bad in concurrency,\nbecause it’s not common to deployt it with\n<a href=\"http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface\">WSGI</a>, but\nrun it on top of a barely known last millennium asynchronous HTTP server\ncalled <a href=\"http://www.nightmare.com/medusa/\">Medusa</a>.</p>\n<p>See, The out-of-the-box installation of Plone launches with only a\nsingle asynchronous HTTP server with just two fixed long-running worker\nthreads. And it’s way too easy to write custom code to keep those\nworker threads busy (for example, by with writing blocking calls to\nexternal services), effectively resulting denial of service for rest of\nthe incoming requests</p>\n<p>Well, as far as I know, the real bottleneck is not Medusa, but the way\nhow <a href=\"http://en.wikipedia.org/wiki/Zope_Object_Database\">ZODB</a> database\nconnections work. It seems that to optimize the database connection\nrelated caches, ZODB is best used with fixed amount of concurrent worker\nthreads, and one dedicated database connection per thread. Finally,\n<a href=\"http://en.wikipedia.org/wiki/Multiversion_concurrency_control\">MVCC</a> in\nZODB limits each thread can serve only one request at time.</p>\n<p>In practice, of course, Plone-sites use ZEO-clustering (and replication)\nto overcome the limitations described above.</p>\n<p><strong>Back to the topic (with a disclaimer).</strong> The methods described in this\nblog post have not been battle tested yet and they may turn out to be\nbad ideas. Still, it’s been fun to figure out how our old asynchronous\nfriend, Medusa, could be used to serve more concurrent request in\ncertain special cases.</p>\n<h2>ZPublisher stream iterators</h2>\n<p>If you have been working with Plone long enough, you must have heard the\nrumor that blobs, which basically means files and images, are served\nfrom the filesystem in some special non-blocking way.</p>\n<p>So, when someone downloads a file from Plone, the current worker thread\nonly initiates the download and can then continue to serve the next\nrequest. The actually file is left to be served asynchronously by the\nmain thread.</p>\n<p>This is possible because of a ZPublisher feature called <em>stream\niterators</em> (search IStreamIterator interface and its implementations in\nZope2 and plone.app.blobs). Stream iterators are basically a way to\npostpone I/O-bound operations into the main thread’s asyncore loop\nthrough a special Medusa-level producer object.</p>\n<p>And because stream iterators are consumed only within the main thread,\nthey come with some very strict limitations:</p>\n<ul>\n<li>they are executed only after a completed transaction so they cannot\ninteract with the transaction anymore</li>\n<li>they must not read from the ZODB (because their origin connection is\neither closed or in use of their origin worker thread)</li>\n<li>they must not fail unexpectedly, because you don’t want to crash\nthe main thread</li>\n<li>they must not block the main thread, for obvious reasons.</li>\n</ul>\n<p>Because of these limitations, the stream iterators, as such, are usable\nonly for the purpose they have been made for: streaming files or similar\nimmediately available buffers.</p>\n<h2>Asynchronous stream iterators</h2>\n<p>What if you could use ZPublisher’s stream iterator support also for\nCPU-bound post-processing tasks? Or for post-processing tasks requiring\ncalls to external web services or command-line utilities?</p>\n<p>If you have a local Plone instance running somewhere, you can add the\nfollowing proof-of-concept code and its <code>slow_ok</code>-method into a new\n<a href=\"http://docs.zope.org/zope2/zope2book/ScriptingZope.html#using-external-methods\">External\nMethod</a>\n(also available as a\n<a href=\"https://gist.github.com/datakurre/b273a6bf9285ee779542\">gist</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">StringIO</span><span>\n</span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">threading</span><span>\n\n</span><span class=\"cm-keyword\">from</span><span> </span><span class=\"cm-variable\">zope</span><span>.</span><span class=\"cm-property\">interface</span><span> </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">implements</span><span>\n</span><span class=\"cm-keyword\">from</span><span> </span><span class=\"cm-variable\">ZPublisher</span><span>.</span><span class=\"cm-property\">Iterators</span><span> </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">IStreamIterator</span><span>\n</span><span class=\"cm-keyword\">from</span><span> </span><span class=\"cm-variable\">ZServer</span><span>.</span><span class=\"cm-property\">PubCore</span><span>.</span><span class=\"cm-property\">ZEvent</span><span> </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">Wakeup</span><span>\n\n</span><span class=\"cm-keyword\">from</span><span> </span><span class=\"cm-variable\">zope</span><span>.</span><span class=\"cm-property\">globalrequest</span><span> </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">getRequest</span><span>\n\n\n</span><span class=\"cm-keyword\">class</span><span> </span><span class=\"cm-def\">zhttp_channel_async_wrapper</span><span>(</span><span class=\"cm-builtin\">object</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-string\">\"\"\"Medusa channel wrapper to defer producers until released\"\"\"</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">__init__</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">channel</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the current Zope worker thread)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_channel</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">channel</span><span>\n\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_mutex</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">threading</span><span>.</span><span class=\"cm-property\">Lock</span><span>()</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_deferred</span><span> </span><span class=\"cm-operator\">=</span><span> []</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_released</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-keyword\">False</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_content_length</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-number\">0</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">_push</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span class=\"cm-operator\">=</span><span class=\"cm-number\">1</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">if</span><span> (</span><span class=\"cm-builtin\">isinstance</span><span>(</span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-builtin\">str</span><span>)</span><span>\n</span><span>                </span><span class=\"cm-keyword\">and</span><span> </span><span class=\"cm-variable\">producer</span><span>.</span><span class=\"cm-property\">startswith</span><span>(</span><span class=\"cm-string\">'HTTP/1.1 200 OK'</span><span>)):</span><span>\n</span><span>            </span><span class=\"cm-comment\"># Fix Content-Length to match the real content length</span><span>\n</span><span>            </span><span class=\"cm-comment\"># (an alternative would be to use chunked encoding)</span><span>\n</span><span>            </span><span class=\"cm-variable\">producer</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">producer</span><span>.</span><span class=\"cm-property\">replace</span><span>(</span><span>\n</span><span>                </span><span class=\"cm-string\">'Content-Length: 0\\r\\n'</span><span>,</span><span>\n</span><span>                </span><span class=\"cm-string\">'Content-Length: {0:s}\\r\\n'</span><span>.</span><span class=\"cm-property\">format</span><span>(</span><span class=\"cm-builtin\">str</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_content_length</span><span>))</span><span>\n</span><span>            )</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_channel</span><span>.</span><span class=\"cm-property\">push</span><span>(</span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span>)</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">push</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span class=\"cm-operator\">=</span><span class=\"cm-number\">1</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the current Zope worker thread)</span><span>\n</span><span>        </span><span class=\"cm-keyword\">with</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_mutex</span><span>:</span><span>\n</span><span>            </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-keyword\">not</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_released</span><span>:</span><span>\n</span><span>                </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_deferred</span><span>.</span><span class=\"cm-property\">append</span><span>((</span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span>))</span><span>\n</span><span>            </span><span class=\"cm-keyword\">else</span><span>:</span><span>\n</span><span>                </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_push</span><span>(</span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span>)</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">release</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">content_length</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the exclusive async thread)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_content_length</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">content_length</span><span>\n</span><span>        </span><span class=\"cm-keyword\">with</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_mutex</span><span>:</span><span>\n</span><span>            </span><span class=\"cm-keyword\">for</span><span> </span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span> </span><span class=\"cm-keyword\">in</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_deferred</span><span>:</span><span>\n</span><span>                </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_push</span><span>(</span><span class=\"cm-variable\">producer</span><span>, </span><span class=\"cm-variable\">send</span><span>)</span><span>\n</span><span>            </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_released</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-keyword\">True</span><span>\n</span><span>        </span><span class=\"cm-variable\">Wakeup</span><span>()  </span><span class=\"cm-comment\"># wake up the asyncore loop to read our results</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">__getattr__</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">key</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-builtin\">getattr</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_channel</span><span>, </span><span class=\"cm-variable\">key</span><span>)</span><span>\n\n\n</span><span class=\"cm-keyword\">class</span><span> </span><span class=\"cm-def\">AsyncWorkerStreamIterator</span><span>(</span><span class=\"cm-variable\">StringIO</span><span>.</span><span class=\"cm-property\">StringIO</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-string\">\"\"\"Stream iterator to publish the results of the given func\"\"\"</span><span>\n\n</span><span>    </span><span class=\"cm-variable\">implements</span><span>(</span><span class=\"cm-variable\">IStreamIterator</span><span>)</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">__init__</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">func</span><span>, </span><span class=\"cm-variable\">response</span><span>, </span><span class=\"cm-variable\">streamsize</span><span class=\"cm-operator\">=</span><span class=\"cm-number\">1</span><span> </span><span class=\"cm-operator\">&lt;&lt;</span><span> </span><span class=\"cm-number\">16</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the current Zope worker thread)</span><span>\n\n</span><span>        </span><span class=\"cm-comment\"># Init buffer</span><span>\n</span><span>        </span><span class=\"cm-variable\">StringIO</span><span>.</span><span class=\"cm-property\">StringIO</span><span>.</span><span class=\"cm-property\">__init__</span><span>(</span><span class=\"cm-variable-2\">self</span><span>)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_streamsize</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">streamsize</span><span>\n\n</span><span>        </span><span class=\"cm-comment\"># Wrap the Medusa channel to wait for the func results</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_channel</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">response</span><span>.</span><span class=\"cm-property\">stdout</span><span>.</span><span class=\"cm-property\">_channel</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_wrapped_channel</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">zhttp_channel_async_wrapper</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_channel</span><span>)</span><span>\n</span><span>        </span><span class=\"cm-variable\">response</span><span>.</span><span class=\"cm-property\">stdout</span><span>.</span><span class=\"cm-property\">_channel</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_wrapped_channel</span><span>\n\n</span><span>        </span><span class=\"cm-comment\"># Set content-length as required by ZPublisher</span><span>\n</span><span>        </span><span class=\"cm-variable\">response</span><span>.</span><span class=\"cm-property\">setHeader</span><span>(</span><span class=\"cm-string\">'content-length'</span><span>, </span><span class=\"cm-string\">'0'</span><span>)</span><span>\n\n</span><span>        </span><span class=\"cm-comment\"># Fire the given func in a separate thread</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">thread</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">threading</span><span>.</span><span class=\"cm-property\">Thread</span><span>(</span><span class=\"cm-variable\">target</span><span class=\"cm-operator\">=</span><span class=\"cm-variable\">func</span><span>, </span><span class=\"cm-variable\">args</span><span class=\"cm-operator\">=</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">callback</span><span>,))</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">thread</span><span>.</span><span class=\"cm-property\">start</span><span>()</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">callback</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">data</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the exclusive async thread)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">write</span><span>(</span><span class=\"cm-variable\">data</span><span>)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">seek</span><span>(</span><span class=\"cm-number\">0</span><span>)</span><span>\n</span><span>        </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_wrapped_channel</span><span>.</span><span class=\"cm-property\">release</span><span>(</span><span class=\"cm-builtin\">len</span><span>(</span><span class=\"cm-variable\">data</span><span>))</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-builtin\">next</span><span>(</span><span class=\"cm-variable-2\">self</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-comment\"># (executed within the main thread)</span><span>\n</span><span>        </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-keyword\">not</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">closed</span><span>:</span><span>\n</span><span>            </span><span class=\"cm-variable\">data</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">read</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_streamsize</span><span>)</span><span>\n</span><span>            </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-keyword\">not</span><span> </span><span class=\"cm-variable\">data</span><span>:</span><span>\n</span><span>                </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">close</span><span>()</span><span>\n</span><span>            </span><span class=\"cm-keyword\">else</span><span>:</span><span>\n</span><span>                </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-variable\">data</span><span>\n</span><span>        </span><span class=\"cm-keyword\">raise</span><span> </span><span class=\"cm-variable\">StopIteration</span><span>\n\n</span><span>    </span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">__len__</span><span>(</span><span class=\"cm-variable-2\">self</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-builtin\">len</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">getvalue</span><span>())</span><span>\n\n\n</span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">slow_ok_worker</span><span>(</span><span class=\"cm-variable\">callback</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-comment\"># (executed within the exclusive async thread)</span><span>\n</span><span>    </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">time</span><span>\n</span><span>    </span><span class=\"cm-variable\">time</span><span>.</span><span class=\"cm-property\">sleep</span><span>(</span><span class=\"cm-number\">1</span><span>)</span><span>\n</span><span>    </span><span class=\"cm-variable\">callback</span><span>(</span><span class=\"cm-string\">'OK'</span><span>)</span><span>\n\n\n</span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">slow_ok</span><span>():</span><span>\n</span><span>    </span><span class=\"cm-string\">\"\"\"The publishable example method\"\"\"</span><span>\n</span><span>    </span><span class=\"cm-comment\"># (executed within the current Zope worker thread)</span><span>\n</span><span>    </span><span class=\"cm-variable\">request</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">getRequest</span><span>()</span><span>\n</span><span>    </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-variable\">AsyncWorkerStreamIterator</span><span>(</span><span class=\"cm-variable\">slow_ok_worker</span><span>, </span><span class=\"cm-variable\">request</span><span>.</span><span class=\"cm-property\">response</span><span>)</span></code></pre>\n    </div>\n<p>The above code example simulates a trivial post-processing with\n<code>time.sleep</code>, but it should apply for anything from building a PDF from\nthe extracted data to calling an external web service before returning\nthe final response.</p>\n<p>An out-of-the-box Plone instance can handle only two (2) concurrent\ncalls to a method, which would take one (1) second to complete.</p>\n<p>In the above code, however, the post-processing could be delegated to a\ncompletely new thread, freeing the Zope worker thread to continue to\nhandle the next request. Because of that, we can get much much better\nconcurrency:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ ab</span><span> </span><span class=\"cm-attribute\">-c</span><span> </span><span class=\"cm-number\">100</span><span> </span><span class=\"cm-attribute\">-n</span><span> </span><span class=\"cm-number\">100</span><span> http://localhost:8080/Plone/slow_ok</span><span>\n</span><span>This is ApacheBench, Version </span><span class=\"cm-number\">2</span><span>.3 &lt;</span><span class=\"cm-def\">$Revision</span><span>: </span><span class=\"cm-number\">655654</span><span> </span><span class=\"cm-def\">$&gt;</span><span>\n</span><span>Copyright </span><span class=\"cm-number\">1996</span><span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><span>\n</span><span>Licensed to The Apache Software Foundation, http://www.apache.org/</span><span>\n\n</span><span>Benchmarking localhost (be patient).....done</span><span>\n\n</span><span>Server Software:        Zope/(2.13.22,</span><span>\n</span><span>Server Hostname:        localhost</span><span>\n</span><span>Server Port:            </span><span class=\"cm-number\">8080</span><span>\n\n</span><span>Document Path:          /Plone/slow_ok</span><span>\n</span><span>Document Length:        </span><span class=\"cm-number\">2</span><span> bytes</span><span>\n\n</span><span>Concurrency Level:      </span><span class=\"cm-number\">100</span><span>\n</span><span>Time taken </span><span class=\"cm-keyword\">for</span><span> tests:   </span><span class=\"cm-number\">1</span><span>.364 seconds</span><span>\n</span><span>Complete requests:      </span><span class=\"cm-number\">100</span><span>\n</span><span>Failed requests:        </span><span class=\"cm-number\">0</span><span>\n</span><span>Write errors:           </span><span class=\"cm-number\">0</span><span>\n</span><span>Total transferred:      </span><span class=\"cm-number\">15400</span><span> bytes</span><span>\n</span><span>HTML transferred:       </span><span class=\"cm-number\">200</span><span> bytes</span><span>\n</span><span>Requests per second:    </span><span class=\"cm-number\">73</span><span>.32 [</span><span class=\"cm-comment\">#/sec] (mean)</span><span>\n</span><span>Time per request:       </span><span class=\"cm-number\">1363</span><span>.864 [ms] (mean)</span><span>\n</span><span>Time per request:       </span><span class=\"cm-number\">13</span><span>.639 [ms] (mean, across all concurrent requests)</span><span>\n</span><span>Transfer rate:          </span><span class=\"cm-number\">11</span><span>.03 [Kbytes/sec] received</span><span>\n\n</span><span>Connection Times (ms)</span><span>\n</span><span>               min  mean[</span><span class=\"cm-operator\">+</span><span>/-sd] median   max</span><span>\n</span><span>Connect:        </span><span class=\"cm-number\">1</span><span>    </span><span class=\"cm-number\">2</span><span>   </span><span class=\"cm-number\">0</span><span>.6      </span><span class=\"cm-number\">2</span><span>       </span><span class=\"cm-number\">3</span><span>\n</span><span>Processing:  </span><span class=\"cm-number\">1012</span><span> </span><span class=\"cm-number\">1196</span><span>  </span><span class=\"cm-number\">99</span><span>.2   </span><span class=\"cm-number\">1202</span><span>    </span><span class=\"cm-number\">1359</span><span>\n</span><span>Waiting:     </span><span class=\"cm-number\">1011</span><span> </span><span class=\"cm-number\">1196</span><span>  </span><span class=\"cm-number\">99</span><span>.3   </span><span class=\"cm-number\">1202</span><span>    </span><span class=\"cm-number\">1359</span><span>\n</span><span>Total:       </span><span class=\"cm-number\">1015</span><span> </span><span class=\"cm-number\">1199</span><span>  </span><span class=\"cm-number\">98</span><span>.6   </span><span class=\"cm-number\">1204</span><span>    </span><span class=\"cm-number\">1361</span><span>\n\n</span><span>Percentage of the requests served within a certain time (ms)</span><span>\n</span><span>  </span><span class=\"cm-number\">50</span><span>%   </span><span class=\"cm-number\">1204</span><span>\n</span><span>  </span><span class=\"cm-number\">66</span><span>%   </span><span class=\"cm-number\">1256</span><span>\n</span><span>  </span><span class=\"cm-number\">75</span><span>%   </span><span class=\"cm-number\">1283</span><span>\n</span><span>  </span><span class=\"cm-number\">80</span><span>%   </span><span class=\"cm-number\">1301</span><span>\n</span><span>  </span><span class=\"cm-number\">90</span><span>%   </span><span class=\"cm-number\">1331</span><span>\n</span><span>  </span><span class=\"cm-number\">95</span><span>%   </span><span class=\"cm-number\">1350</span><span>\n</span><span>  </span><span class=\"cm-number\">98</span><span>%   </span><span class=\"cm-number\">1357</span><span>\n</span><span>  </span><span class=\"cm-number\">99</span><span>%   </span><span class=\"cm-number\">1361</span><span>\n</span><span>  </span><span class=\"cm-number\">100</span><span>%   </span><span class=\"cm-number\">1361</span><span> (longest request)</span></code></pre>\n    </div>\n<p>Of course, most of the stream iterator limits still apply: Asynchronous\nstream iterator must not access the database, which limits the possible\nuse cases a lot. For the same reasons, also\n<a href=\"https://pypi.python.org/pypi/plone.transformchain\">plone.transformchain</a>\nis effectively skipped (no\n<a href=\"https://pypi.python.org/pypi/plone.app.theming\">Diazo</a> or\n<a href=\"https://pypi.python.org/pypi/plone.app.blocks\">Blocks</a>), which limits\nthis to be usable only for non-HTML responses.</p>\n<h2>experimental.promises</h2>\n<p>To go experimenting even further, what if you could do similar\nnon-blocking asynchronous processing in the middle of a request? For\nexample, to free the current Zope working thread while fetching a\nmissing or outdated RSS feed in a separate thread and only then continue\nto render the final response.</p>\n<p>An interesting side effect of using streaming iterators is that they\nallow you to inject code into the main thread’s asynchronous loop. And\nwhen you are there, it’s even possible to queue completely new request\nfor ZPublisher to handle.</p>\n<p>So, how would the following approach sound like:</p>\n<ul>\n<li>\n<p>let add-on code to annotate requests with\n<a href=\"http://en.wikipedia.org/wiki/Futures_and_promises\">promises</a> for\nfetching the required data (each promise would be a standalone\nfunction, which could be executed under the asynchronous stream\niterator rules, and when called, would resolve into a value,\neffectively the <em>future</em> of the promise), for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-meta\">@property</span><span>\n</span><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">content</span><span>(</span><span class=\"cm-variable-2\">self</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-string\">'my_unique_key'</span><span> </span><span class=\"cm-keyword\">in</span><span> </span><span class=\"cm-variable\">IFutures</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-variable\">IFutures</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>)[</span><span class=\"cm-string\">'my_unique_key'</span><span>]</span><span>\n</span><span>    </span><span class=\"cm-keyword\">else</span><span>:</span><span>\n</span><span>        </span><span class=\"cm-variable\">IPromises</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>)[</span><span class=\"cm-string\">'my_unique_key'</span><span>] </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">my_promise_func</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-string\">u''</span></code></pre>\n    </div>\n</li>\n<li>\n<p>when promises are found, the response is turned into an asynchronous\nstream iterator, which would then execute all the promises in\nparallel threads and collects the resolved values, futures:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-def\">transformIterable</span><span>(</span><span class=\"cm-variable-2\">self</span><span>, </span><span class=\"cm-variable\">result</span><span>, </span><span class=\"cm-variable\">encoding</span><span>):</span><span>\n</span><span>    </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-variable\">IPromises</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>):</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-variable\">PromiseWorkerStreamIterator</span><span>(</span><span>\n</span><span>            </span><span class=\"cm-variable\">IPromises</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>), </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>, </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">request</span><span>.</span><span class=\"cm-property\">response</span><span>)</span><span>\n</span><span>    </span><span class=\"cm-keyword\">else</span><span>:</span><span>\n</span><span>        </span><span class=\"cm-keyword\">return</span><span> </span><span class=\"cm-keyword\">None</span></code></pre>\n    </div>\n</li>\n<li>\n<p>finally, we’d wrap the current Medusa channel in a way that instead\nof publishing any data yet, a cloned request is queued for the\nZPublisher (similarly how retries are done after conflict errors),\nbut those cloned request and annotated to carry the resolved\nfutures:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-keyword\">def</span><span> </span><span class=\"cm-builtin\">next</span><span>(</span><span class=\"cm-variable-2\">self</span><span>):</span><span>\n</span><span>   </span><span class=\"cm-keyword\">if</span><span> </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_futures</span><span>:</span><span>\n</span><span>       </span><span class=\"cm-variable\">IFutures</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_zrequest</span><span>).</span><span class=\"cm-property\">update</span><span>(</span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_futures</span><span>)</span><span>\n</span><span>       </span><span class=\"cm-variable-2 error\">self</span><span>.</span><span class=\"cm-property\">_futures</span><span> </span><span class=\"cm-operator\">=</span><span> {}  </span><span class=\"cm-comment\"># mark consumed to raise StopIteration</span><span>\n\n</span><span>       </span><span class=\"cm-keyword\">from</span><span> </span><span class=\"cm-variable\">ZServer</span><span>.</span><span class=\"cm-property\">PubCore</span><span> </span><span class=\"cm-keyword\">import</span><span> </span><span class=\"cm-variable\">handle</span><span>\n</span><span>       </span><span class=\"cm-variable error\">handle</span><span>(</span><span class=\"cm-string\">'Zope2'</span><span>, </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_zrequest</span><span>, </span><span class=\"cm-variable-2\">self</span><span>.</span><span class=\"cm-property\">_zrequest</span><span>.</span><span class=\"cm-property\">response</span><span>)</span><span>\n</span><span>   </span><span class=\"cm-keyword error\">else</span><span>:</span><span>\n</span><span>       </span><span class=\"cm-keyword\">raise</span><span> </span><span class=\"cm-variable\">StopIteration</span></code></pre>\n    </div>\n</li>\n<li>\n<p>now the add-on code in question would find the futures from request,\nnot issue any promises anymore and the request would result a normal\nresponse pushed all the way to the browser, which initiated the\noriginal request.</p>\n</li>\n</ul>\n<p>I’m not sure yet, how good or bad idea this would be, but I’ve been\ntinkering with a proof-of-concept implementation called\n<a href=\"https://github.com/datakurre/experimental.promises\">experimental.promises</a>\nto figure it out.</p>\n<p>Of course, there are limits and issues to be aware of. Handling the same\nrequest twice is not free, which makes approach effective only when some\nsignificant processing can be moved to be done outside the worker\nthreads. Also, because there may be other request between the first and\nthe second pass (freeing the worker to handle other request is the whole\npoint), the database may change between the passes (kind of breaking the\nMVCC promise). Finally, currently it’s possible write the code always\nset new promises and end into never ending loop.</p>\n<p>Anyway, if you are interested to try out these approaches (at your own\nrisk, of course), feel free to ask more via Twitter or IRC.</p>","frontmatter":{"title":"Asynchronous stream iterators and experimental promises for Plone","tags":["Async","Asyncore","Plone","Python"],"date":"May 04, 2014","published":"2014-05-04 06:00:00"}}},"pageContext":{"slug":"/2014/05/asynchronous-stream-iterators-and.html/","previous":{"fields":{"slug":"/2014/03/cross-browser-selenium-testing-with.html/"},"frontmatter":{"title":"Cross-Browser Selenium testing with Robot Framework and Sauce Labs"}},"next":{"fields":{"slug":"/2014/09/nix-expressions-as-executable-commands.html/"},"frontmatter":{"title":"Nix expressions as executable commands"}}}},"staticQueryHashes":["63159454"],"slicesMap":{}}