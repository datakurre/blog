{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014/09/nix-expressions-as-executable-commands.html/","result":{"data":{"site":{"siteMetadata":{"title":"Asko Soukka","author":"Asko Soukka"}},"markdownRemark":{"id":"068cc61c-6cd8-5a2d-b0d8-21b300d21dc1","fields":{"slug":"/2014/09/nix-expressions-as-executable-commands.html/"},"excerpt":"Updated 2015-07-07: Stateless Nix environment\nrevisited\nConsider this entry deprecated. Updated 2014-09-24: I learned that in a mixed (OSX and nixpkgs…","html":"<p><strong>Updated 2015-07-07:</strong> <a href=\"http://datakurre.pandala.org/2015/07/stateless-nix-environments-revisited.html\">Stateless Nix environment\nrevisited</a>\nConsider this entry deprecated.</p>\n<p><strong>Updated 2014-09-24:</strong> I learned that in a mixed (OSX and nixpkgs)\nenvironment, one should not set <code>LD_LIBRARY_PATH</code>, but fix dynamic\nlinking to use absolute paths. Yet, I refactored my wrapper to use\n<em>myEnvFun</em> when required (see the buildout example).</p>\n<p><strong>Updated 2014-09-22:</strong> I was wrong about, how nix-built Python\nenvironments could be used together with\n<a href=\"https://pypi.python.org/pypi/zc.buildout\">buildout</a> and updated this\npost to reflect my experiences.</p>\n<p>My main tools for Python based software development have been\n<a href=\"https://pypi.python.org/pypi/virtualenv\">virtualenv</a> and\n<a href=\"https://pypi.python.org/pypi/zc.buildout\">buildout</a> for a long time.\nI’ve used virtualenv for providing isolated Python installation\n(separate from so often polluted system python) and buildout for\nmanaging both the required Python packages, developed packages, and\nsupporting software (like Redis or memcached).</p>\n<p>Basically everything still works, but:</p>\n<ul>\n<li>Managing clean Python virtualenvs for only to avoid possible\nconflicts with system installed packages feels a lot of work with a\nsmall return.</li>\n<li>Remembering to activate and deactivate the correct Python virtualenv\nis not fun either.</li>\n<li>Also, while buildout provides excellent tool\n(<a href=\"https://pypi.python.org/pypi/mr.developer\">mr.developer</a>) for\nmanaging sources for all the project packages, it’s far from\noptimal for building and managing supporting (not Python) software.</li>\n</ul>\n<p>I’ve also using quite a bit of Vagrant and Docker, but, because I’m\nmostly working on Mac, those require a VM, which makes them much less\nconvenient.</p>\n<h2>About Nix</h2>\n<p>I believe, I heard about <a href=\"http://nixos.org/nix/\">Nix</a> package manager\nfrom <a href=\"http://garbas.si/\">Rok</a> at the first time at <a href=\"http://www.coactivate.org/projects/barcelona-sprint\">Barcelona Plone\nTesting Sprint</a> in\nthe early 2013. It sounded a bit esoteric and complex back then, but\nafter about about twenty months of more virtualenvs, buildouts,\nVagrantfiles, Docker containers and puppet manifests… not so much\nanymore.</p>\n<p>Currently, outside <a href=\"http://nixos.org/\">NixOS</a>, I understand Nix as</p>\n<ol>\n<li>a functional language for describing configuration of software and</li>\n<li>a package manager for managing those configurations.</li>\n</ol>\n<p>From my own experience, the easiest way to get familiar with Nix is to\nfollow <a href=\"https://www.domenkozar.com/\">Domen</a>’s <a href=\"https://www.domenkozar.com/2014/01/02/getting-started-with-nix-package-manager/\">blog post about getting\nstarted with Nix package\nmanager</a>.\nBut to really make it a new tool to your toolbox, you should learn to\n<a href=\"http://nixos.org/nix/manual/#chap-writing-nix-expressions\">write your own Nix\nexpressions</a>.</p>\n<p>Even the the most common way to use the Nix package manager is to\ninstall Nix expressions into your current environment with <strong>nix-env</strong>,\nthe expressions can also be used without really installing them, in a\nquite stateless way.</p>\n<p>I’m not sure how proper use of Nix this is, but it seems to work for\nme.</p>\n<p>(Yes, I’m aware of <strong>myEnvFun</strong>, for creating named stateful\ndevelopment environments with Nix expressions, but here I’m trying to\nuse Nix in a more stateless, Docker-inspired way.)</p>\n<h2>Nix expressions as virtualenv replacements</h2>\n<p>It’s almost never safe to install a Python software directly into your\nsystem Python. Different software may require different versions of same\nlibraries and sooner than later the conflicting requirements break your\nPython installation.</p>\n<p>Let’s take a small utility software called <a href=\"https://pypi.org/project/i18ndude/\">i18ndude</a> as an example\nof such software with way too frightening dependencies for any system\nPython. Traditionally, you could install it into a separate Python\nvirtualenv and use it with the following steps:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ virtualenv</span><span> ~/.../i18ndude-env</span><span>\n</span><span class=\"cm-def\">$ source</span><span> ~/.../i18ndude-env/bin/activate</span><span>\n</span><span class=\"cm-def\">$ pip</span><span> install i18ndude</span><span>\n</span><span class=\"cm-def\">$ i18ndude</span><span>\n</span><span>...</span><span>\n</span><span class=\"cm-def\">$ deactivate</span></code></pre>\n    </div>\n<p>With an executable Nix expression, I can call it in a stateless way with\nsimply executing the expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span>./i18ndude.nix</span><span>\n</span><span>➜ /nix/store/gjhzw843qs1736r0qcd9mz69247g4svb-python2.7-i18ndude-3.3.5/bin/i18ndude</span><span>\n</span><span>usage: i18ndude [-h]</span><span>\n</span><span>                {find-untranslated,rebuild-pot,merge,sync,filter,admix,list,trmerge}</span><span>\n</span><span>                ...</span><span>\n</span><span>18ndude: error: too few arguments</span></code></pre>\n    </div>\n<p>Maybe even better, I can install the expression into my default Nix\nenvironment with</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ nix</span><span class=\"cm-attribute\">-env</span><span> </span><span class=\"cm-attribute\">-i</span><span> </span><span class=\"cm-attribute\">-f</span><span> i18ndude.nix</span></code></pre>\n    </div>\n<p>and use it like it would have been installed into my system Python in\nthe first place (but this time without polluting it):</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ i18ndude</span><span>.nix</span><span>\n</span><span>usage: i18ndude [-h]</span><span>\n</span><span>                {find-untranslated,rebuild-pot,merge,sync,filter,admix,list,trmerge}</span><span>\n</span><span>                ...</span><span>\n</span><span>18ndude: error: too few arguments</span></code></pre>\n    </div>\n<p>No more activating or deactivating virtualenvs, not to mention about\nneeding to remember their names or locations.</p>\n<p>For the most common Python softare, it’s not required to write your own\nexpression, but you could simply install the contributed expressions\ndirectly from Nix packages repository.</p>\n<p>The easiest way to check for existing expressions from nixpkgs Python\npackages seems to be grepping the package list with\n<code>nix-env -qaP \\*|grep something</code>.</p>\n<p>If you’d like to see more packages available by default, you can\ncontribute them to\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/python-packages.nix\">upstream</a>\nwith a simple pull request.</p>\n<p>Anyway, since <a href=\"https://pypi.org/project/i18ndude/\">i18ndude</a> was not yet available in time of writing\n(although, most of its dependencies were), this is how my expression for\nit looked like:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>#!/usr/bin/env nix-exec\nwith import &lt;nixpkgs&gt; { };\n\nlet dependencies = rec {\n  ordereddict = buildPythonPackage {\n    name = \"ordereddict-1.1\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/o/ordereddict/ordereddict-1.1.tar.gz\";\n      md5 = \"a0ed854ee442051b249bfad0f638bbec\";\n    };\n  };\n};\n\nin with dependencies; rec {\n  i18ndude = buildPythonPackage {\n    name = \"i18ndude-3.3.5\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/i/i18ndude/i18ndude-3.3.5.zip\";\n      md5 = \"ef599b1c64eaabba4049fcd2b027ba21\";\n    };\n    propagatedBuildInputs = [\n      ordereddict\n      python27Packages.\"zope.tal-3.5.2\"\n      python27Packages.\"plone.i18n-2.0.9\"\n    ];\n  };\n}</span></code></pre>\n    </div>\n<h2>Nix expression for <em>nix-exec</em> shell wrapper</h2>\n<p>Of course, Nix expressions are not executable by default. To get them\nwork as I wanted, I had to create tiny <a href=\"https://gist.github.com/datakurre/7a3c9eaf6ba51e9d8bd5\">wrapper\nscript</a> to be\nused as the hash-bang line <code>#!/usr/bin/env nix-exec</code> of executable\nexpressions.</p>\n<p>The script simply calls <strong>nix-build</strong> and then the named executable from\nthe build output directory (with some standard environment variables\nset). To put it another way, the wrapper script translates the following\ncommand:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span>./i18ndude.nix </span><span class=\"cm-attribute\">--help</span></code></pre>\n    </div>\n<p>into</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span class=\"cm-quote\">`nix-build --no-out-link i18ndude.nix`</span><span>/bin/i18ndude </span><span class=\"cm-attribute\">--help</span></code></pre>\n    </div>\n<p>It’s not required to suffix the expressions fiels with <code>.nix</code>, but they\ncould also be named without suffix to look more like real commands.</p>\n<p>The wrapper script itself, of course, can be installed from a Nix\nexpression into your default Nix environment with\n<code>nix-env -i -f filename.nix</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>with import &lt;nixpkgs&gt; { };\n\nstdenv.mkDerivation {\n  name = \"datakurre-nix-exec-1.2.1\";\n\n  builder = builtins.toFile \"builder.sh\" \"\n    source $stdenv/setup\n    mkdir -p $out/bin\n    echo \\\"#!/bin/bash\nbuild=\\\\`nix-build --no-out-link \\\\$1\\\\`\nif [ \\\\$build ]; then\n\n  MY_TZ=\\\\\\\"\\\\$TZ\\\\\\\"\n  MY_PATH=\\\\\\\"\\\\$build/bin:\\\\$build/sbin:\\\\$build/libexec:\\\\$PATH\\\\\\\"\n  MY_http_proxy=\\\\\\\"\\\\$http_proxy\\\\\\\"\n  MY_ftp_proxy=\\\\\\\"\\\\$http_proxy\\\\\\\"\n\n  if [ -d \\\\$build/dev-envs ]; then\n    source \\\\\\\"\\\\$build/dev-envs/\\\\\\\"*\n\n    export TZ=\\\\\\\"\\\\$MY_TZ\\\\\\\"\n    export PATH=\\\\\\\"\\\\$PATH:\\\\$MY_PATH\\\\\\\"\n    export http_proxy=\\\\\\\"\\\\$MY_http_proxy\\\\\\\"\n    export ftp_proxy=\\\\\\\"\\\\$MY_ftp_proxy\\\\\\\"\n\n    export CFLAGS=\\\\`echo \\\\$NIX_CFLAGS_COMPILE|sed 's/-isystem /-I/g'\\\\`\n    export LDFLAGS=\\\\$NIX_LDFLAGS\n  else\n    export PATH=\\\\\\\"\\\\$MY_PATH\\\\\\\"\n  fi\n\n  cmd=\\\\$\\{1##*/\\}; cmd=\\\\$\\{cmd%%@*\\}; cmd=\\\\$\\{cmd%.nix\\}\n  paths=(\\\\\\\"\\\\$build/bin\\\\\\\" \\\\\\\"\\\\$build/sbin\\\\\\\" \\\\\\\"\\\\$build/libexec\\\\\\\")\n  for path in \\\\\\\"\\\\$\\{paths[@]\\}\\\\\\\"; do\n    if [ -f \\\\\\\"\\\\$path/\\\\$\\{cmd\\}\\\\\\\" ]; then\n      cmd=\\\\\\\"\\\\$path/\\\\$\\{cmd\\}\\\\\\\"\n      break\n    fi\n  done\n\n  if [ -t 1 ]; then echo \\\\\\\"➜\\\\\\\" \\\\$cmd \\\\\\\"\\\\$\\{@:2\\}\\\\\\\"; fi\n  \\\\\\\"\\\\$cmd\\\\\\\" \\\\\\\"\\\\$\\{@:2\\}\\\\\\\"\nfi\n\\\" &gt; $out/bin/nix-exec\n    chmod a+x $out/bin/nix-exec\n  \";\n}</span></code></pre>\n    </div>\n<p>The wrapper does execute the expression defined command in a fully clean\nenvironment (the only isolation is the one <em>myEnvFun</em> provides), but\nmostly prepends everything defined by the expression into its\nsurrounding execution environment (so that its paths are preferred over\nthe versions in the current environment).</p>\n<p>A mostly positive side effect from using Nix expressions like this (only\nbuilding them, but not installing them into any environment) is that\nthey can be cleaned (from the disk) anytime with simply:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ nix</span><span class=\"cm-attribute\">-collect-garbage</span></code></pre>\n    </div>\n<h2>Nix expressions with buildout</h2>\n<p><strong>Update 2014-09-24:</strong> The example was updated to use <em>myEnvFun</em> to\nsimplify the wrapper script.</p>\n<p><strong>Update 2014-09-22:</strong> I originally covered Nix expressions with\nbuildout as an example of replacing Python virtualenvs with Nix.\nUnfortunately, because of some buildout limitations that didn’t work\nout as I expected…</p>\n<p>A very special case of Python development environment is the one with\n<a href=\"https://pypi.python.org/pypi/zc.buildout\">buildout</a>, which is required\ne.g. for all development with <a href=\"http://plone.org/\">Plone</a>.</p>\n<p>When using Nix expressions with\n<a href=\"https://pypi.python.org/pypi/zc.buildout\">buildout</a>, there is a one\nvery special limitation: <strong>buildout does not support any additional\nPython packages installed into your Nix expression based environment</strong>.</p>\n<p>That’s because buildout sees Nix defined Python as a system Python, and\nbuildout does its best to prevent any extra packages installed into\nsystem Python being available for the buildout by default.</p>\n<p>An additional issue for buildout is that the extra Python packages\ndefined in Nix expression are not installed directly into under the\nPython installation, but are made available only when that Python is\nexecuted through a specialc Nix generated wrapper.</p>\n<p>But to cut this short, here’s an example executable Nix expression,\nwhich could be used as a <a href=\"http://plone.org/\">Plone</a>-compatible Python\nenvironment. It includes a clean Python installation with some\nadditional (non-Python) libraries required by Plone buildout to be able\nto compile a few special Python packages (like <a href=\"https://pypi.org/project/Pillow/\">Pillow</a>, <a href=\"https://pypi.org/project/lxml/\">lxml</a> and\n<a href=\"https://pypi.org/project/python-ldap/\">python-ldap</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>#!/usr/bin/env nix-exec\nwith import &lt;nixpkgs&gt; { };\n\nlet dependencies = rec {\n  buildInputs = [\n    cyrus_sasl\n    openldap\n    libxslt\n    libxml2\n    freetype\n    libpng\n    libjpeg\n    python27Full\n  ];\n};\n\nin with dependencies; buildEnv {\n  name = \"nix\";\n  paths = [(myEnvFun { name = \"nix\"; inherit buildInputs; })] ++ buildInputs;\n}</span></code></pre>\n    </div>\n<p>With this Nix expression named as an executable <code>./python.nix</code>, it could\nbe used to execute buildout’s bootstrap, buildout and eventually\nlaunching the Plone site like:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span>./python.nix bootstrap.py</span><span>\n</span><span class=\"cm-def\">$ </span><span>./python.nix bin/buildout  </span><span class=\"cm-comment\"># or ./python.nix -S bin/buildout</span><span>\n</span><span class=\"cm-def\">$ </span><span>./python.nix bin/instance fg</span></code></pre>\n    </div>\n<p>I must agree that this is not as convenient as it should be, because\neach command (bootstrap, buildout and the final buildout generated\nscript) must be executed explicitly using our executable Nix expression\ndefining the required Python-environment.</p>\n<p>Also, probably because my wrapper does not completely isolate the Nix\nexpression call from its surrounding environment, sometimes it’s\nrequired to call the buildout with <code>-S</code> given for the Python expression,\nlike <code>./python.nix -S bin/buildout</code> (otherwise buildout does not find\nit’s own bootstrapped installation).</p>\n<p>On the other hand, this approach defines the execution environment\nexplicitly and statelessly for each call.</p>\n<p>P.S. Because I’m working with RHEL systems, it’s nice to use Python\nwith similar configuration with those. With Nix, it’s easy to define\nlocal overrides for existing packages (nixpkgs derivations) there’s a\nspecial function with only the required configuration changes. The\nfollowing <code>~/.nixpkgs/config.nix</code>-example configures Python with similar\nunicode flag to RHEL’s native Python:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>{\n  packageOverrides = pkgs : with pkgs; rec {\n    python27 = pkgs.python27.overrideDerivation (args: {\n      configureFlags = \"--enable-shared --with-threads --enable-unicode=ucs4\";\n    }) // { modules = pkgs.python27.modules; };\n  };\n}</span></code></pre>\n    </div>\n<h2>Nix expressions as stateless development environments</h2>\n<p><strong>Updated 2014-09-24:</strong> Because of OSX, I had to fix openldap expression\nto fix link one library with absolute path to not allow it to resolve an\nOSX library instead of the Nix built one.</p>\n<p>In test driven development, the whole development environment can be\nbuilt just around the selected test runner.</p>\n<p>Here’s an example Nix expression, which saved as an executable file\ncalled <code>./py.test</code> can be used to execute <a href=\"https://pypi.org/project/pytest/\">pytest</a> test runner with a\ncouple of selected plugins and all the dependencies required by the\ntested software in question:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>#!/usr/bin/env nix-exec\nwith import &lt;nixpkgs&gt; { };\n\nlet dependencies = rec {\n  execnet = buildPythonPackage {\n    name = \"execnet-1.2.0\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/e/execnet/execnet-1.2.0.tar.gz\";\n      md5 = \"1886d12726b912fc2fd05dfccd7e6432\";\n    };\n    doCheck = false;\n  };\n  pycparser = buildPythonPackage {\n    name = \"pycparser-2.10\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/p/pycparser/pycparser-2.10.tar.gz\";\n      md5 = \"d87aed98c8a9f386aa56d365fe4d515f\";\n    };\n  };\n  cffi = buildPythonPackage {\n    name = \"cffi-0.8.6\";\n    src = fetchurl {\n      url = \"http://pypi.python.org/packages/source/c/cffi/cffi-0.8.6.tar.gz\";\n      md5 = \"474b5a68299a6f05009171de1dc91be6\";\n    };\n    propagatedBuildInputs = [ pycparser ];\n  };\n  pytest_cache = buildPythonPackage {\n    name = \"pytest-cache-1.0\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/p/pytest-cache/pytest-cache-1.0.tar.gz\";\n      md5 = \"e51ff62fec70a1fd456d975ce47977cd\";\n    };\n    propagatedBuildInputs = [\n       python27Packages.pytest\n       execnet\n    ];\n  };\n  pytest_flakes = buildPythonPackage {\n    name = \"pytest-flakes-0.2\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/p/pytest-flakes/pytest-flakes-0.2.zip\";\n      md5 = \"44b8f9746fcd827de5c02f14b01728c1\";\n    };\n    propagatedBuildInputs = [\n       python27Packages.pytest\n       python27Packages.pyflakes\n       pytest_cache\n    ];\n  };\n  pytest_pep8 = buildPythonPackage {\n    name = \"pytest-pep8-1.0.6\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/p/pytest-pep8/pytest-pep8-1.0.6.tar.gz\";\n      md5 = \"3debd0bac8f63532ae70c7351e73e993\";\n    };\n    propagatedBuildInputs = [\n      python27Packages.pytest\n      python27Packages.pep8\n      pytest_cache\n    ];\n  };\n  buildInputs = [\n    (python27Packages.pytest.override {\n      propagatedBuildInputs = [\n        python27Packages.readline\n        python27Packages.plumbum\n        python27Packages.py\n        pytest_flakes\n        pytest_pep8\n      ];\n    })\n    (lib.overrideDerivation openldap (args: {\n      postBuild = if stdenv.isDarwin then ''\n        install_name_tool -change /libsasl2.dylib ${cyrus_sasl}/lib/libsasl2.dylib servers/slapd/slapadd\n     '' else null;\n    }))\n  ];\n};\n\nin with dependencies; buildEnv {\n  name = \"nix\";\n  paths = [(myEnvFun { name = \"nix\"; inherit buildInputs; })] ++ buildInputs;\n}</span></code></pre>\n    </div>\n<p>In other words, this expression could work as a stateless environment\nfor developing the product in question:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span>./py.test</span><span>\n</span><span>➜ /nix/store/a2w3hwc66gqm6bncic8km6b69lw2byc6-py.test/bin/py.test</span><span>\n</span><span class=\"cm-operator\">==================================</span><span> test session starts </span><span class=\"cm-operator\">==================================</span><span>\n</span><span>platform darwin </span><span class=\"cm-attribute\">--</span><span> Python </span><span class=\"cm-number\">2</span><span>.7.8 </span><span class=\"cm-attribute\">--</span><span> pytest-2.5.1</span><span>\n</span><span>plugins: flakes, cache, pep8</span><span>\n</span><span>collected </span><span class=\"cm-number\">2</span><span> items</span><span>\n\n</span><span>src/.../tests/test_things.py ..</span><span>\n</span><span class=\"cm-operator\">===============================</span><span> </span><span class=\"cm-number\">2</span><span> passed </span><span class=\"cm-keyword\">in</span><span> </span><span class=\"cm-number\">0</span><span>.22 seconds </span><span class=\"cm-operator\">================================</span></code></pre>\n    </div>\n<p>And, once the development is completed, an another expression could be\ndefined for using the developed product.</p>\n<h2>Nix expression for Robot Framework test runner</h2>\n<p>Finally, as a bonus, here’s an expression, which configures a Python\nenvironment with <a href=\"http://robotframework.org\">Robot Framework</a> and its\n<a href=\"https://pypi.python.org/pypi/robotframework-selenium2library\">Selenium2Library</a>\nwith <a href=\"http://phantomjs.org\">PhantomJS</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-solarized\"><code><span>#!/usr/bin/env nix-exec\nwith import &lt;nixpkgs&gt; { };\n\nlet dependencies = rec {\n  docutils = buildPythonPackage {\n    name = \"docutils-0.12\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/d/docutils/docutils-0.12.tar.gz\";\n      md5 = \"4622263b62c5c771c03502afa3157768\";\n    };\n  };\n  selenium = buildPythonPackage {\n    name = \"selenium-2.43.0\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/s/selenium/selenium-2.43.0.tar.gz\";\n      md5 = \"bf2b46caa5c1ea4b68434809c695d69b\";\n    };\n  };\n  decorator = buildPythonPackage {\n    name = \"decorator-3.4.0\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/d/decorator/decorator-3.4.0.tar.gz\";\n      md5 = \"1e8756f719d746e2fc0dd28b41251356\";\n    };\n  };\n  robotframework = buildPythonPackage {\n    name = \"robotframework-2.8.5\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/r/robotframework/robotframework-2.8.5.tar.gz\";\n      md5 = \"2d2c6938830f71a6aa6f4be32227997f\";\n    };\n    propagatedBuildInputs = [\n      docutils\n    ];\n  };\n  robotframework-selenium2library = buildPythonPackage {\n    name = \"robotframework-selenium2library-1.5.0\";\n    src = fetchurl {\n      url = \"https://pypi.python.org/packages/source/r/robotframework-selenium2library/robotframework-selenium2library-1.5.0.tar.gz\";\n      md5 = \"07c64a9e183642edd682c2b79ba2f32c\";\n    };\n    propagatedBuildInputs = [\n      robotframework\n      decorator\n      selenium\n    ];\n  };\n};\n\nin with dependencies; buildEnv {\n  name = \"pybot\";\n  paths = [\n    phantomjs\n    (robotframework.override {\n      propagatedBuildInputs = [ robotframework-selenium2library ];\n    })\n  ];\n}</span></code></pre>\n    </div>\n<p>Since you may need differently configured Robot Framework installations\n(with different add-on keyword libraries installed) for different\nprojects, this should be a good fit as an executable Nix expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-solarized\"><code><span class=\"cm-def\">$ </span><span>./pybot.nix</span><span>\n</span><span>➜ /nix/store/q15bimgng25qcxkq2q10finyk0n6qkm2-pybot/bin/pybot</span><span>\n</span><span>[ ERROR ] Expected at least </span><span class=\"cm-number\">1</span><span> argument, got </span><span class=\"cm-number\">0</span><span>.</span><span>\n\n</span><span>Try </span><span class=\"cm-attribute\">--help</span><span> </span><span class=\"cm-keyword\">for</span><span> usage information.</span></code></pre>\n    </div>","frontmatter":{"title":"Nix expressions as executable commands","tags":["Nix","Python"],"date":"September 11, 2014","published":"2014-09-11 06:00:00"}}},"pageContext":{"slug":"/2014/09/nix-expressions-as-executable-commands.html/","previous":{"fields":{"slug":"/2014/05/asynchronous-stream-iterators-and.html/"},"frontmatter":{"title":"Asynchronous stream iterators and experimental promises for Plone"}},"next":{"fields":{"slug":"/2014/10/too-many-ways-to-do-async-tasks-with.html/"},"frontmatter":{"title":"Too many ways to do async tasks with Plone"}}}},"staticQueryHashes":["63159454"],"slicesMap":{}}